# SPDX-FileCopyrightText: 2023 Koen van Greevenbroek & Aleksander Grochowicz
#
# SPDX-License-Identifier: GPL-3.0-or-later

"""Perform MGA.

Specifically, optimise a PyPSA network in the principle directions
with a near-optimality constraint. This leads to a first approximation
of the near-optimal feasible space.

"""

import copy
import logging
import multiprocessing
import os
import time
import warnings
from collections import OrderedDict
from multiprocessing import Pool, get_context
from pathlib import Path

import numpy as np
from utilities import (
    get_basis_values,
    solve_network_in_direction,
)
from workflow_utilities import parse_net_spec, configure_logging

# Ignore futurewarnings raised by pandas from inside pypsa, at least
# until the warning is fixed. This needs to be done _before_ pypsa and
# pandas are imported; ignore the warning this generates.
warnings.simplefilter(action="ignore", category=FutureWarning)

import pandas as pd  # noqa: E402
import pypsa  # noqa: E402


def mga(
    n: pypsa.Network,
    basis: OrderedDict,
    opt_point: pd.DataFrame,
    obj_bound: float,
    debug_dir: str,
    num_parallel_solvers: int,
) -> pd.DataFrame:
    """Perform MGA in given basis with maximum objective `obj_bound`.

    Obtain the extremal points in the basis directions, which come from a
    projection of the entire feasible space of `n` onto the lower-dimensional
    space spanned by a selection of decision variables (or sums of decision
    variables). Specifically, the projection is the span of the vectors given
    by the `basis` argument. The elements of this collection are assumed to
    be linear expressions generated by `pypsa.linopt.linexpr`.

    The near-optimal feasible space is defined as the feasible space
    of `n` with the additional constraint 'c.x <= (1 + `eps`) * OPT',
    where c is the objective function and OPT the optimal value, given here
    by `obj_bound`.

    The return value is a collection of points given in the basis
    specified by `basis`. The convex hull of these points is a first
    approximation of the near-optimal feasible space of `n`.

    Parameters
    ----------
    n : pypsa.Network
    basis : OrderedDict
        A basis on which to project the feasible space of `n`. The
        keys being the decision variables with values given in the
        format produced by `pypsa.linopt.linexpr`.
    opt_point : pd.DataFrame
        Coordinates of the cost-optimal solution in the projection defined by
        `basis`.
    obj_bound : float
        Upper bound for costs in the near-optimality constraint.
    debug_dir : str
        Directory where the debug files (networks) should be saved.
    num_parallel_solvers : int
        The number of parallel processes to use.

    Returns
    -------
    pd.DataFrame
        A collection of points in the basis of `basis`, whose
        convex hull is a first approximation of the near-optimal feasible
        (MGA) space of the given model.
    """
    # Make a copy of the input network so we do not modify the arguments.
    m = n.copy()
    m.config = n.config
    m.opts = n.opts

    # Prepare the near-optimal feasible space, represented by a
    # collection of points. Initially, it just contains the optimal
    # solution. This point has index '-1' for our purposes.
    points = opt_point
    points.index = [-1]

    # Make sure the directory we put the debug networks in exists.
    Path(debug_dir).mkdir(exist_ok=True, parents=True)

    # Generate the direction to optimise in.
    mga_directions = list(np.eye(len(basis))) + list(-np.eye(len(basis)))

    # Make some easy-to-read descriptions for the directions.
    comps = list(basis.keys())
    descriptions = ["min_" + c for c in comps] + ["max_" + c for c in comps]

    # Start a pool of worker processes:
    logging.info("Starting MGA optimisations.")
    with get_context("spawn").Pool(num_parallel_solvers) as pool:
        args = [
            (m, d, basis, obj_bound, debug_dir, desc)
            for d, desc in zip(mga_directions, descriptions)
        ]
        results = pool.starmap_async(mga_worker, args).get()

    # Collect all the resulting points in one dataframe. It is indexed
    # from -1, with the '-1'-th point being the optimum solution.
    result_dfs = [pd.DataFrame(r, index=[0]) for r in results if r is not None]
    points = pd.concat([opt_point] + result_dfs, ignore_index=True)
    points.index = range(-1, len(result_dfs))
    return points


def mga_worker(
    n: pypsa.Network,
    direction: np.array,
    basis: OrderedDict,
    obj_bound: float,
    debug_dir: str,
    description: str,
):
    """Run MGA in given basis with maximum objective `obj_bound` in parallel."""
    # Log the start of this iteration. Note that we cannot really use
    # the `logging` package here since it is not process-safe, so we
    # just use a print statement. At least it lets the user know
    # what is going on.
    worker_name = multiprocessing.current_process().name
    print(f"{worker_name}: Solving for {description}...")

    m = n.copy()
    m.config = n.config
    m.opts = n.opts

    # Solve the network.
    t = time.time()
    status, termination_condition = solve_network_in_direction(
        m, direction, basis, obj_bound
    )
    solve_time = round(time.time() - t)
    print(f"{worker_name}: Finished solving for {description} in {solve_time} seconds")

    # Export the network for debug purposes. Don't worry if this fails
    # for some reason.
    try:
        m.export_to_netcdf(
            os.path.join(debug_dir, f"{description}.nc"),
            compression={
                "complevel": 1,
                "zlib": True,
                "least_significant_digit": 3,
            },
        )
    except Exception as e:
        print(f"{worker_name}: Failed to export network for {description}: {e}")

    # If the solve was successful, return the results. Otherwise,
    # return nothing. Unsuccessful solves can happen sporadically due
    # to, for example, numerical issues.
    if status == "ok":
        return get_basis_values(m, basis)
    else:
        # If the status is not "ok" (in which case it's "warning"),
        # it's possible that the network still contains useful but
        # sub-optimal results. This is the case when the termination
        # condition is "suboptimal". We print a warning but still use
        # the results.
        if termination_condition == "suboptimal":
            print(
                f"{worker_name}: Suboptimal solution for {description};"
                " still using results."
            )
            return get_basis_values(m, basis)
        else:
            print(f"{worker_name}: Optimisation unsuccessful: ignoring results.")
            return None


if __name__ == "__main__":
    # Set up logging so that everything is written to the right log file.
    configure_logging(snakemake)

    # Disable logging from pypsa; it mostly just distracts for this script.
    pypsa_logger = logging.getLogger("pypsa")
    pypsa_logger.setLevel(logging.WARNING)

    # Load the network and solving options.
    n = pypsa.Network(snakemake.input.network)

    # Attach solving configuration to the network.
    n.config = snakemake.config["pypsa-longyearbyen"]
    n.opts = parse_net_spec(snakemake.wildcards.spec)["opts"].split("-")

    # Load other inputs (the optimal point, the near-optimality
    # constraint) to the MGA computation.
    opt_point = pd.read_csv(snakemake.input.optimum, index_col=0)
    with open(snakemake.input.obj_bound, "r") as f:
        obj_bound = float(f.read())

    # Perform MGA to get a number of points on the boundary of the
    # projected near-optimal feasible space.
    mga_space = mga(
        n,
        basis=snakemake.config["projection"],
        opt_point=opt_point,
        obj_bound=obj_bound,
        debug_dir=snakemake.log.debug,
        num_parallel_solvers=snakemake.config["near_opt_approx"].get(
            "num_parallel_solvers", 1
        ),
    )

    # Write to result to the given output files.
    mga_space.to_csv(snakemake.output.mga_space)
