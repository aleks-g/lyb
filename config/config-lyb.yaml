# SPDX-FileCopyrightText: 2024 Aleksander Grochowicz & Koen van Greevenbroek
#
# SPDX-License-Identifier: CC0-1.0

# The name needs to match the filename of this config.
name: "lyb"

scenario:
  eps: "0.05uni"
  simpl: ""
  planning_horizon: "2050"
  opts: ""
  year: "2015"

# The following config section relates to how the near-optimal
# feasible space is approximated.
near_opt_approx:
  # Essential configuration:
  
  # Direction generation method, either "facets", "random-uniform",
  # "random-lhc", "maximal-centre" or "maximal-centre-then-facets".
  directions: "maximal-centre-then-facets-then-random"
  # Minimum angle threshold between directions.
  directions_angle_separation: 45
  # The number of parallel solvers used in the near-optimal feasible
  # space approximation.
  num_parallel_solvers: 10

  # Convergence configuration. All in all, the below means that the
  # near-optimal space approximation will terminate when the volume
  # changes by less than `conv_epsilon` percent for any `conv_iterations` 
  # consecutive iterations, or after `iterations` iterations at most. 
  # Number of iterations.
  iterations: 1500
  # Convergence method, either "centre" or "volume".
  conv_method: "volume"
  # Convergence epsilon in percent.
  conv_epsilon: 0.5
  # Number of iterations for which the convergence criterion must be
  # below the convergence epsilon before the approximation stops.
  conv_iterations: 200

  # Command line options for the `qhull` program, which is used to
  # compute convex hulls, may be defined here. Whatever the options
  # used, it should work well with inputs that are scaled to the unit
  # cube. (See http://www.qhull.org/html/qh-optq.htm for more details
  # about options).
  qhull_options:
    # Used for routine convex hull computations (e.g. in compute_near_opt)
    near_opt: "Qt"
    # Used when an approximate convex hull computation is needed
    # (input spaces in intersection computation)
    near_opt_approx: "Qt C5e-3 W1e-2"
    # Used for halfspace intersection computations
    intersection: "Qt C5e-3 W1e-2"

  # Angle tolerance: when no new directions are found which are at
  # least this number of degrees away from previously used directions,
  # we stop the approximation.
  # angle_tolerance: 0.1

# Specification of the sample points we want from the approximated near-optimal space.
sample:
  num_sample: 200
  # Number of parallel solvers.
  num_parallel: 24

# Specification of the basis we project the near-optimal feasible space onto. 
projection:
  onwind:
  - {c: "Generator", v: "p_nom", carrier: "onwind", weight: "capital_cost", scale_by_years: True}
  #offwind:
  solar:
  - {c: "Generator", v: "p_nom", carrier: "PV", weight: "capital_cost", scale_by_years: True}
  #geothermal:
  #bioenergy:
  #heat-storage:
  # battery:
  # - {c: "StorageUnit", v: "p_nom", carrier: "battery", weight: "capital_cost", scale_by_years: True}
  # h2:
  # - {c: "StorageUnit", v: "p_nom", carrier: "H2", weight: "capital_cost", scale_by_years: True}
  # demand:

# Provide some readable labels of the above dimensions for figures.
projection_labels:
  onwind: "Onshore wind"
  offwind: "Offshore wind"
  solar: "Solar"
  geothermal: "Geothermal"
  bioenergy: "Bioenergy"
  heat-storage: "Heat storage"
  battery: "Battery"
  h2: "Hydrogen"
  demand: "Demand"

# Apply some formatting to the logging so each entry shows the time it was logged.
logging:
  format: "%(asctime)s %(levelname)s %(module)s - %(funcName)s: %(message)s"
  datefmt: "%Y-%m-%d %H:%M:%S"

# The following section is used as pypsa-longyearbyen configuration (updating its default config).
pypsa-longyearbyen:
  #costs:
  #storage:
  #system:

  #snapshots:
  solving:
    tmpdir: "./tmp"
    threads: 2
    solver:
      name: gurobi
      threads: 4
      methods: 2
      crossover: 0
      BarConvTol: 1.e-5
      FeasibilityTol: 1.e-6
      AggFill: 0
      PreDual: 0
      GURO_PAR_BARDENSETHRESH: 200



